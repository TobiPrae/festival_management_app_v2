

from google.cloud import datastore
import streamlit as st
import pandas as pd
import json

def get_json(file_name):
    """
    Loads data from json
    """

    # Load JSON file
    with open(f'data/{file_name}.json', 'r') as f:
        json_output = json.load(f)

    return json_output

def require_login():
    users = st.secrets.get("users", {})

    if "logged_in" not in st.session_state:
        st.session_state.logged_in = False

    if not st.session_state.logged_in:
        st.title("Login erforderlich")
        username = st.text_input("Benutzername")
        password = st.text_input("Passwort", type="password")
        if st.button("Anmelden"):
            if username in users and users[username] == password:
                st.session_state.logged_in = True
                st.session_state.username = username
                st.rerun()
            else:
                st.error("Ung√ºltiger Benutzername oder Passwort")
        st.stop()

    # Sidebar logout button
    st.sidebar.success(f"Angemeldet als: {st.session_state.username}")
    if st.sidebar.button("Abmelden"):
        st.session_state.logged_in = False
        st.session_state.username = ""
        st.rerun()

def read_from_datastore(kind):
    """
    Reads all entities of a given kind from Google Cloud Datastore and returns them as a list of dictionaries,
    each including its Datastore ID under the key 'id'.

    Args:
        kind (str): The Datastore kind to query.

    Returns:
        data(list): List of entity dictionaries, each with an 'id' field added.
    """
    service_account_info = dict(st.secrets["service_account_key"])
    client = datastore.Client.from_service_account_info(service_account_info)

    query = client.query(kind=kind)
    results = list(query.fetch())

    data = []
    for entity in results:
        record = dict(entity)
        record["ID"] = entity.key.id_or_name  # Add the entity ID (autogenerated or named)
        data.append(record)

    return data

def delete_from_datastore(kind, id_):
    """
    Delete a Datastore entity by kind and ID.

    Args:
        kind (str): The Datastore kind.
        id_ (int or str): The ID of the entity to delete.
    """
    # Initialize Datastore client
    service_account_info = dict(st.secrets["service_account_key"])
    client = datastore.Client.from_service_account_info(service_account_info)

    # Create a key for the entity to delete
    key = client.key(kind, id_)

    # Delete the entity from Datastore
    client.delete(key)



def update_to_datastore(kind, entity_id, updated_fields):
    """
    Loads an existing entity by ID from Datastore, updates specific fields, and writes it back.

    Args:
        kind (str): The Datastore kind.
        entity_id (int or str): The ID of the entity to update.
        updated_fields (dict): Fields to update.
    """
    # Initialize Datastore client
    service_account_info = dict(st.secrets["service_account_key"])
    client = datastore.Client.from_service_account_info(service_account_info)

    # Create the key for the existing entity
    key = client.key(kind, entity_id)

    # Retrieve the entity
    entity = client.get(key)

    if entity is None:
        raise ValueError(f"Entity with ID {entity_id} not found in kind '{kind}'.")

    # Update fields
    for field, value in updated_fields.items():
        entity[field] = value

    # Save updated entity back to Datastore
    client.put(entity)


def add_to_datastore(kind, data):
    """
    Adds a new entity to a Datastore kind.

    Args:
        kind (str): The Datastore kind to add to.
        data (dict): The data to insert as fields.
    """
    # Initialize Datastore client
    service_account_info = dict(st.secrets["service_account_key"])
    client = datastore.Client.from_service_account_info(service_account_info)

    # Create an incomplete key (ID will be auto-generated)
    key = client.key(kind)

    # Create a new entity with that key
    entity = datastore.Entity(key=key)

    # Set the entity's fields
    entity.update(data)

    # Store it in Datastore
    client.put(entity)

def recalculate_expenses():
    """
    Recalculates the total 'actual_cost' per 'responsible' from the 'todos' kind
    and updates the 'expenses' kind in Cloud Datastore accordingly.

    - Creates or updates entities in 'expenses' with fields:
        - responsible
        - actual_cost (sum of all their todos)
        - actual_cost_paid (kept or initialized as 0.0)
    - Deletes any 'expenses' entities for responsibles no longer present in 'todos'
    """

    # Initialize Datastore client from Streamlit secrets
    service_account_info = dict(st.secrets["service_account_key"])
    client = datastore.Client.from_service_account_info(service_account_info)

    # Read todos and convert to DataFrame
    todos = read_from_datastore("todos")  # Assumes this returns a list of dicts
    
    df_todos = pd.DataFrame(todos)

    # Group by 'responsible' and sum actual_cost
    summary_todos = df_todos.groupby("responsible")[["actual_cost"]].sum().reset_index()
    current_responsibles = set(summary_todos["responsible"])

    for _, row in summary_todos.iterrows():
        responsible = row["responsible"]
        new_cost = float(row["actual_cost"])

        # Use 'responsible' as key name for the "expenses" entity
        key = client.key("expenses", responsible)
        existing = client.get(key)

        if existing:
            # Compare old vs. new cost
            old_cost = float(existing.get("actual_cost", 0.0))
            if old_cost != new_cost:
                existing["actual_cost"] = new_cost
                client.put(existing)
        else:
            # Create a new entity if it doesn't exist
            entity = datastore.Entity(key=key)
            entity.update({
                "responsible": responsible,
                "actual_cost": new_cost,
                "actual_cost_paid": 0.0
            })
            client.put(entity)

        query = client.query(kind="expenses")
    all_expenses = list(query.fetch())

    for e in all_expenses:
        r = e.get("responsible")
        if r not in current_responsibles:
            key = client.key("expenses", r)
            client.delete(key)


def add_property(kind, property, default_value):
    """
    Adds a new property with a default value to all entities of a given kind
    in Google Cloud Datastore, if the property does not already exist.

    Parameters:
    - kind (str): The Datastore kind (equivalent to a table name).
    - property (str): The name of the new property to add.
    - default_value (Any): The default value to assign to the new property.

    This function uses a service account key provided via Streamlit secrets.
    """
    service_account_info = dict(st.secrets["service_account_key"])
    client = datastore.Client.from_service_account_info(service_account_info)

    query = client.query(kind=kind)

    for entity in query.fetch():
        if property not in entity:
            entity[property] = default_value
            client.put(entity)